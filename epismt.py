# -*- coding: utf-8 -*-
"""517_proj_prep_for_github.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14QxcrJiNaoT1-YZ49_HpSV5Th4Ame_T9
"""

# Commented out IPython magic to ensure Python compatibility.
# Run this section first.
#
# Note: you will have to type a 'Y' into two prompts in order to install msat and cvc4.
# Also note: it will take a while to build cvc4, but you can leave once you press 'Y' twice.

import random
import networkx
import pysmt

from pysmt.shortcuts import Symbol, And, GE, LT, Plus, Equals, Int, get_model, Implies, LE, Or, Bool, Not, Exists, ForAll
from pysmt.typing import INT, BOOL


# Implements algorithm 1 from the paper
def grow_connections_in_time(graph, time, p):
    spread_graph = networkx.DiGraph()
    spread_graph.add_nodes_from(graph)

    for steps in range(time):
        for starting_node in spread_graph.nodes:
            previously_infected = list(spread_graph.successors(starting_node))
            for immediate_neighbor in graph.adj[starting_node]:
                if random.random() < p:
                    spread_graph.add_edge(starting_node, immediate_neighbor)
            
            for potential_spreader in previously_infected:
                for node_neighboring_infected in graph.adj[potential_spreader]:
                    if random.random() < p:
                        spread_graph.add_edge(starting_node, node_neighboring_infected)
    return spread_graph


# Constructs an SMT formula from a graph
# Note: the graph has to be the output of grow_connections_in_time()
def construct_spread_formula_from_graph(spread_graph, limit, target):
    initial_infection_ints = [Symbol('init_int_' + str(i), INT) for i in spread_graph.nodes]
    final_infection_ints = [Symbol('final_int_' + str(i), INT) for i in spread_graph.nodes]

    spreading_clauses = []
    origin_clauses = []
    all_bounds = []

    # Here, we ensure that, if node i is selected as an initial infector, all of its neighbors are also infected:
    for starting_node in spread_graph.nodes:
        initial_infection_bounds = And(LE(initial_infection_ints[int(starting_node)], Int(1)), GE(initial_infection_ints[int(starting_node)], Int(0)))

        infected_neighbors = And([Equals(final_infection_ints[int(i)], Int(1)) for i in spread_graph.successors(starting_node)])
        infected_nodes = And(infected_neighbors, Equals(final_infection_ints[int(starting_node)], Int(1)))
        spreading_forumla = Implies(Equals(initial_infection_ints[int(starting_node)], Int(1)), infected_nodes)

        spreading_clauses.append(spreading_forumla)
        all_bounds.append(initial_infection_bounds)
    
    
    # Here, we ensure that, if node i becomes infected, either it was infected by an initial infectors with an edge to node i
    # of node i itself was an initial infector.
    for infected_node in spread_graph.nodes:
        final_infection_bounds = And(LE(final_infection_ints[int(infected_node)], Int(1)), GE(final_infection_ints[int(infected_node)], Int(0)))

        origin_neighbors = Or([Equals(initial_infection_ints[int(i)], Int(1)) for i in spread_graph.predecessors(infected_node)])
        origin_nodes = Or(origin_neighbors, Equals(initial_infection_ints[int(infected_node)], Int(1)))
        origin_formula = Implies(Equals(final_infection_ints[int(infected_node)], Int(1)), origin_nodes)

        origin_clauses.append(origin_formula)
        all_bounds.append(final_infection_bounds)
    
    initial_infection_limit = LE(Plus(initial_infection_ints), Int(limit))
    final_infection_target = GE(Plus(final_infection_ints), Int(target))

    return And(And(spreading_clauses), And(origin_clauses), And(all_bounds), initial_infection_limit, final_infection_target), initial_infection_ints, final_infection_ints


# Constructs the quantified vaccination formula from a graph
def construct_vaccination_formula_from_graph(spread_graph, limit, target, n_vaccinations):
    initial_infection_ints = [Symbol('init_int_' + str(i), INT) for i in spread_graph.nodes]
    final_infection_ints = [Symbol('final_int_' + str(i), INT) for i in spread_graph.nodes]
    vaccination_ints = [Symbol('vax_' + str(i), INT) for i in spread_graph.nodes]


    spreading_clauses = []
    origin_clauses = []
    all_bounds = []
    vaccination_clauses = []

    # Here, we ensure that, if node i is selected as an initial infector, all of its neighbors are also infected:
    for starting_node in spread_graph.nodes:
        initial_infection_bounds = And(LE(initial_infection_ints[int(starting_node)], Int(1)), GE(initial_infection_ints[int(starting_node)], Int(0)))

        infected_neighbors = And([Equals(final_infection_ints[int(i)], Int(1)) for i in spread_graph.successors(starting_node)])
        infected_nodes = And(infected_neighbors, Equals(final_infection_ints[int(starting_node)], Int(1)))
        spreading_forumla = Implies(Equals(initial_infection_ints[int(starting_node)], Int(1)), infected_nodes)

        spreading_clauses.append(spreading_forumla)
        all_bounds.append(initial_infection_bounds)
    
    
    # Here, we ensure that, if node i becomes infected, either it was infected by an initial infectors with an edge to node i
    # of node i itself was an initial infector.
    for infected_node in spread_graph.nodes:
        final_infection_bounds = And(LE(final_infection_ints[int(infected_node)], Int(1)), GE(final_infection_ints[int(infected_node)], Int(0)))

        origin_neighbors = Or([Equals(initial_infection_ints[int(i)], Int(1)) for i in spread_graph.predecessors(infected_node)])
        origin_nodes = Or(origin_neighbors, Equals(initial_infection_ints[int(infected_node)], Int(1)))
        origin_formula = Implies(Equals(final_infection_ints[int(infected_node)], Int(1)), origin_nodes)

        origin_clauses.append(origin_formula)
        all_bounds.append(final_infection_bounds)
    
    initial_infection_limit = LE(Plus(initial_infection_ints), Int(limit))
    final_infection_target = LE(Plus(final_infection_ints), Int(target - 1))


    # Here, we ensure that, if node i is selected as a vaccine recipiant, it won't be infected:
    for vaccinatable_node in spread_graph.nodes:
        vaccination_bounds = And(LE(vaccination_ints[int(vaccinatable_node)], Int(1)), GE(vaccination_ints[int(vaccinatable_node)], Int(0)))

        vaccine_works_start = Not(And(Equals(vaccination_ints[int(vaccinatable_node)], Int(1)), Equals(initial_infection_ints[int(vaccinatable_node)], Int(1))))
        vaccine_works_future = Not(And(Equals(vaccination_ints[int(vaccinatable_node)], Int(1)), Equals(final_infection_ints[int(vaccinatable_node)], Int(1))))

        vaccination_clauses.append(vaccine_works_start)
        vaccination_clauses.append(vaccine_works_future)
        all_bounds.append(vaccination_bounds)
    
    
    vaccination_limit = LE(Plus(vaccination_ints), Int(n_vaccinations))

    infection_formula = And(And(spreading_clauses), And(origin_clauses), And(vaccination_clauses), And(all_bounds), initial_infection_limit, final_infection_target, vaccination_limit)
    
    quantified_infection_formula = Exists(vaccination_ints, ForAll(initial_infection_ints, infection_formula))

    return quantified_infection_formula, infection_formula, vaccination_ints


def decide_epidemic(source, size, m, p, limit, target, timesteps, p_infect):
    if source == 'generate':
        contact_network = networkx.watts_strogatz_graph(size, m, p)
    else:
        contact_network = networkx.read_adjlist(source)
    spread_graph = grow_connections_in_time(contact_network, timesteps, p_infect)

    formula, _, _ = construct_spread_formula_from_graph(spread_graph, limit, target)
    model = get_model(formula)
    
    if model:
        return True, model
    else:
        return False, None


def decide_quantified_epidemic(source, size, m, p, limit, target, n_vaccinate, timesteps, p_infect):
    if source == 'generate':
        contact_network = networkx.watts_strogatz_graph(size, m, p)
    else:
        contact_network = networkx.read_adjlist(source)
    spread_graph = grow_connections_in_time(contact_network, timesteps, p_infect)

    formula, _, _ = construct_vaccination_formula_from_graph(spread_graph, limit, target, n_vaccinate)
    model = get_model(formula, solver_name='cvc4')
    
    if model:
        return True, model
    else:
        return False, None
